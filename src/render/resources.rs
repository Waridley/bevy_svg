use crate::origin::Origin;
use crate::prelude::{Svg, SvgMesh2d, SvgMesh3d};
use bevy::asset::Handle;
use bevy::log::warn;
use bevy::math::EulerRot;
use bevy::prelude::*;
use bevy::utils::HashMap;

/// Resource that wraps [lyon_tessellation::FillTessellator]. Can be replaced to
/// change the default settings for all generated SVG meshes.
#[derive(Resource, Deref, DerefMut, Default)]
pub struct FillTessellator(pub lyon_tessellation::FillTessellator);

/// Resource that wraps [lyon_tessellation::StrokeTessellator]. Can be replaced to
/// change the default settings for all generated SVG meshes.
#[derive(Resource, Deref, DerefMut, Default)]
pub struct StrokeTessellator(pub lyon_tessellation::StrokeTessellator);

/// Caches mesh handles generated by [SvgMesh2d] and [SvgMesh3d] to avoid re-computing and
/// storing them for every entity. This allows multiple entities to display the same SVG
/// asset at different sizes, tolerances, flat vs. volumetric, etc. while still re-using
/// meshes whenever possible.
#[derive(Resource, Default, Debug, Deref, DerefMut, Reflect)]
pub struct SvgMeshCache(HashMap<Handle<Svg>, HashMap<SvgMeshKey, Handle<Mesh>>>);

/// The key type for [SvgMeshCache]. Needed because floating-point types do not implement `Hash`
/// or `Eq`.
///
/// Since the cache is simply to avoid extra processing and storage, it is not a significant
/// problem to treat the values as meaningless sets of bits. The worst that is likely to
/// happen is, if size, depth, etc. are computed rather than hard-coded, floating point
/// imprecision could result in multiple meshes for keys that only have a few bits different.
/// Thus, computed values for [SvgMesh2d] and [SvgMesh3d] should be stored and re-used as
/// much as possible.
///
/// This type can only be constructed from an [SvgMesh2d] or [SvgMesh3d].
#[derive(Clone, Default, Debug, Hash, PartialEq, Eq, Reflect)]
pub struct SvgMeshKey {
    origin: Origin,
    size: Option<[u32; 2]>,
    depth: Option<u32>,
    rotation: [u32; 4],
    tolerance: u32,
}

impl From<SvgMesh2d> for SvgMeshKey {
    fn from(value: SvgMesh2d) -> Self {
        Self::from(SvgMesh3d::from(value))
    }
}

impl From<SvgMesh3d> for SvgMeshKey {
    fn from(value: SvgMesh3d) -> Self {
        Self {
            origin: value.origin,
            size: value.size.map(|size| [size.x.to_bits(), size.y.to_bits()]),
            depth: value.depth.map(f32::to_bits),
            rotation: [
                value.rotation.x.to_bits(),
                value.rotation.y.to_bits(),
                value.rotation.z.to_bits(),
                value.rotation.w.to_bits(),
            ],
            tolerance: value.tolerance.to_bits(),
        }
    }
}

impl From<SvgMeshKey> for SvgMesh2d {
    fn from(value: SvgMeshKey) -> Self {
        #[cfg(debug_assertions)]
        if let Some(depth) = value.depth {
            let depth = f32::from_bits(depth);
            warn!(
                ?depth,
                "Discarding depth when converting `SvgMeshKey` to `SvgMesh2d`"
            );
        }
        let mesh_3d = SvgMesh3d::from(value);
        Self {
            origin: mesh_3d.origin,
            size: mesh_3d.size,
            rotation: mesh_3d.rotation.to_euler(EulerRot::ZYX).0,
            tolerance: mesh_3d.tolerance,
        }
    }
}

impl From<SvgMeshKey> for SvgMesh3d {
    fn from(value: SvgMeshKey) -> Self {
        Self {
            origin: value.origin,
            size: value
                .size
                .map(|size| Vec2::new(f32::from_bits(size[0]), f32::from_bits(size[1]))),
            depth: value.depth.map(f32::from_bits),
            rotation: Quat::from_xyzw(
                f32::from_bits(value.rotation[0]),
                f32::from_bits(value.rotation[1]),
                f32::from_bits(value.rotation[2]),
                f32::from_bits(value.rotation[3]),
            ),
            tolerance: f32::from_bits(value.tolerance),
        }
    }
}
